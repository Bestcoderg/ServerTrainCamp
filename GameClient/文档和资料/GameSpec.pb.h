// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GameSpec.proto

#ifndef PROTOBUF_INCLUDED_GameSpec_2eproto
#define PROTOBUF_INCLUDED_GameSpec_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_GameSpec_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_GameSpec_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[15]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_GameSpec_2eproto();
namespace GameSpec {
class AddItemReq;
class AddItemReqDefaultTypeInternal;
extern AddItemReqDefaultTypeInternal _AddItemReq_default_instance_;
class AddItemRsp;
class AddItemRspDefaultTypeInternal;
extern AddItemRspDefaultTypeInternal _AddItemRsp_default_instance_;
class BagInfo;
class BagInfoDefaultTypeInternal;
extern BagInfoDefaultTypeInternal _BagInfo_default_instance_;
class BagItem;
class BagItemDefaultTypeInternal;
extern BagItemDefaultTypeInternal _BagItem_default_instance_;
class CtlMsgLoginReq;
class CtlMsgLoginReqDefaultTypeInternal;
extern CtlMsgLoginReqDefaultTypeInternal _CtlMsgLoginReq_default_instance_;
class CtlMsgLoginRsp;
class CtlMsgLoginRspDefaultTypeInternal;
extern CtlMsgLoginRspDefaultTypeInternal _CtlMsgLoginRsp_default_instance_;
class CtlMsgSearchReq;
class CtlMsgSearchReqDefaultTypeInternal;
extern CtlMsgSearchReqDefaultTypeInternal _CtlMsgSearchReq_default_instance_;
class CtlMsgSearchRsp;
class CtlMsgSearchRspDefaultTypeInternal;
extern CtlMsgSearchRspDefaultTypeInternal _CtlMsgSearchRsp_default_instance_;
class CurrencyItem;
class CurrencyItemDefaultTypeInternal;
extern CurrencyItemDefaultTypeInternal _CurrencyItem_default_instance_;
class EquipItem;
class EquipItemDefaultTypeInternal;
extern EquipItemDefaultTypeInternal _EquipItem_default_instance_;
class Players;
class PlayersDefaultTypeInternal;
extern PlayersDefaultTypeInternal _Players_default_instance_;
class RankReq;
class RankReqDefaultTypeInternal;
extern RankReqDefaultTypeInternal _RankReq_default_instance_;
class RankRsp;
class RankRspDefaultTypeInternal;
extern RankRspDefaultTypeInternal _RankRsp_default_instance_;
class RemoveItemReq;
class RemoveItemReqDefaultTypeInternal;
extern RemoveItemReqDefaultTypeInternal _RemoveItemReq_default_instance_;
class RemoveItemRsp;
class RemoveItemRspDefaultTypeInternal;
extern RemoveItemRspDefaultTypeInternal _RemoveItemRsp_default_instance_;
}  // namespace GameSpec
namespace google {
namespace protobuf {
template<> ::GameSpec::AddItemReq* Arena::CreateMaybeMessage<::GameSpec::AddItemReq>(Arena*);
template<> ::GameSpec::AddItemRsp* Arena::CreateMaybeMessage<::GameSpec::AddItemRsp>(Arena*);
template<> ::GameSpec::BagInfo* Arena::CreateMaybeMessage<::GameSpec::BagInfo>(Arena*);
template<> ::GameSpec::BagItem* Arena::CreateMaybeMessage<::GameSpec::BagItem>(Arena*);
template<> ::GameSpec::CtlMsgLoginReq* Arena::CreateMaybeMessage<::GameSpec::CtlMsgLoginReq>(Arena*);
template<> ::GameSpec::CtlMsgLoginRsp* Arena::CreateMaybeMessage<::GameSpec::CtlMsgLoginRsp>(Arena*);
template<> ::GameSpec::CtlMsgSearchReq* Arena::CreateMaybeMessage<::GameSpec::CtlMsgSearchReq>(Arena*);
template<> ::GameSpec::CtlMsgSearchRsp* Arena::CreateMaybeMessage<::GameSpec::CtlMsgSearchRsp>(Arena*);
template<> ::GameSpec::CurrencyItem* Arena::CreateMaybeMessage<::GameSpec::CurrencyItem>(Arena*);
template<> ::GameSpec::EquipItem* Arena::CreateMaybeMessage<::GameSpec::EquipItem>(Arena*);
template<> ::GameSpec::Players* Arena::CreateMaybeMessage<::GameSpec::Players>(Arena*);
template<> ::GameSpec::RankReq* Arena::CreateMaybeMessage<::GameSpec::RankReq>(Arena*);
template<> ::GameSpec::RankRsp* Arena::CreateMaybeMessage<::GameSpec::RankRsp>(Arena*);
template<> ::GameSpec::RemoveItemReq* Arena::CreateMaybeMessage<::GameSpec::RemoveItemReq>(Arena*);
template<> ::GameSpec::RemoveItemRsp* Arena::CreateMaybeMessage<::GameSpec::RemoveItemRsp>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace GameSpec {

enum ErrorCode {
  ERROR_NO_ERROR = 0,
  ERROR_AUH_ERROR = 1,
  ERROR_SEARCH_FAIL = 2,
  ERROR_REV_ITEM_FAIL = 3,
  ERROR_ADD_ITEM_FAIL = 4,
  ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool ErrorCode_IsValid(int value);
const ErrorCode ErrorCode_MIN = ERROR_NO_ERROR;
const ErrorCode ErrorCode_MAX = ERROR_ADD_ITEM_FAIL;
const int ErrorCode_ARRAYSIZE = ErrorCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ErrorCode_descriptor();
inline const ::std::string& ErrorCode_Name(ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ErrorCode_descriptor(), value);
}
inline bool ErrorCode_Parse(
    const ::std::string& name, ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ErrorCode>(
    ErrorCode_descriptor(), name, value);
}
// ===================================================================

class BagItem final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameSpec.BagItem) */ {
 public:
  BagItem();
  virtual ~BagItem();

  BagItem(const BagItem& from);

  inline BagItem& operator=(const BagItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BagItem(BagItem&& from) noexcept
    : BagItem() {
    *this = ::std::move(from);
  }

  inline BagItem& operator=(BagItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BagItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BagItem* internal_default_instance() {
    return reinterpret_cast<const BagItem*>(
               &_BagItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(BagItem* other);
  friend void swap(BagItem& a, BagItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BagItem* New() const final {
    return CreateMaybeMessage<BagItem>(nullptr);
  }

  BagItem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BagItem>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BagItem& from);
  void MergeFrom(const BagItem& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BagItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 itemID = 1;
  void clear_itemid();
  static const int kItemIDFieldNumber = 1;
  ::google::protobuf::int32 itemid() const;
  void set_itemid(::google::protobuf::int32 value);

  // int32 typeID = 2;
  void clear_typeid_();
  static const int kTypeIDFieldNumber = 2;
  ::google::protobuf::int32 typeid_() const;
  void set_typeid_(::google::protobuf::int32 value);

  // int32 count = 3;
  void clear_count();
  static const int kCountFieldNumber = 3;
  ::google::protobuf::int32 count() const;
  void set_count(::google::protobuf::int32 value);

  // int32 overly = 4;
  void clear_overly();
  static const int kOverlyFieldNumber = 4;
  ::google::protobuf::int32 overly() const;
  void set_overly(::google::protobuf::int32 value);

  // bool binded = 5;
  void clear_binded();
  static const int kBindedFieldNumber = 5;
  bool binded() const;
  void set_binded(bool value);

  // @@protoc_insertion_point(class_scope:GameSpec.BagItem)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 typeid__;
  ::google::protobuf::int32 count_;
  ::google::protobuf::int32 overly_;
  bool binded_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameSpec_2eproto;
};
// -------------------------------------------------------------------

class EquipItem final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameSpec.EquipItem) */ {
 public:
  EquipItem();
  virtual ~EquipItem();

  EquipItem(const EquipItem& from);

  inline EquipItem& operator=(const EquipItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EquipItem(EquipItem&& from) noexcept
    : EquipItem() {
    *this = ::std::move(from);
  }

  inline EquipItem& operator=(EquipItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EquipItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EquipItem* internal_default_instance() {
    return reinterpret_cast<const EquipItem*>(
               &_EquipItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(EquipItem* other);
  friend void swap(EquipItem& a, EquipItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EquipItem* New() const final {
    return CreateMaybeMessage<EquipItem>(nullptr);
  }

  EquipItem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EquipItem>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EquipItem& from);
  void MergeFrom(const EquipItem& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EquipItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 itemID = 1;
  void clear_itemid();
  static const int kItemIDFieldNumber = 1;
  ::google::protobuf::int32 itemid() const;
  void set_itemid(::google::protobuf::int32 value);

  // int32 typeID = 2;
  void clear_typeid_();
  static const int kTypeIDFieldNumber = 2;
  ::google::protobuf::int32 typeid_() const;
  void set_typeid_(::google::protobuf::int32 value);

  // int32 count = 3;
  void clear_count();
  static const int kCountFieldNumber = 3;
  ::google::protobuf::int32 count() const;
  void set_count(::google::protobuf::int32 value);

  // int32 overly = 4;
  void clear_overly();
  static const int kOverlyFieldNumber = 4;
  ::google::protobuf::int32 overly() const;
  void set_overly(::google::protobuf::int32 value);

  // bool binded = 5;
  void clear_binded();
  static const int kBindedFieldNumber = 5;
  bool binded() const;
  void set_binded(bool value);

  // int32 attack = 6;
  void clear_attack();
  static const int kAttackFieldNumber = 6;
  ::google::protobuf::int32 attack() const;
  void set_attack(::google::protobuf::int32 value);

  // int32 durability = 7;
  void clear_durability();
  static const int kDurabilityFieldNumber = 7;
  ::google::protobuf::int32 durability() const;
  void set_durability(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GameSpec.EquipItem)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 typeid__;
  ::google::protobuf::int32 count_;
  ::google::protobuf::int32 overly_;
  bool binded_;
  ::google::protobuf::int32 attack_;
  ::google::protobuf::int32 durability_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameSpec_2eproto;
};
// -------------------------------------------------------------------

class CurrencyItem final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameSpec.CurrencyItem) */ {
 public:
  CurrencyItem();
  virtual ~CurrencyItem();

  CurrencyItem(const CurrencyItem& from);

  inline CurrencyItem& operator=(const CurrencyItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CurrencyItem(CurrencyItem&& from) noexcept
    : CurrencyItem() {
    *this = ::std::move(from);
  }

  inline CurrencyItem& operator=(CurrencyItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CurrencyItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CurrencyItem* internal_default_instance() {
    return reinterpret_cast<const CurrencyItem*>(
               &_CurrencyItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(CurrencyItem* other);
  friend void swap(CurrencyItem& a, CurrencyItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CurrencyItem* New() const final {
    return CreateMaybeMessage<CurrencyItem>(nullptr);
  }

  CurrencyItem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CurrencyItem>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CurrencyItem& from);
  void MergeFrom(const CurrencyItem& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CurrencyItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 itemID = 1;
  void clear_itemid();
  static const int kItemIDFieldNumber = 1;
  ::google::protobuf::int32 itemid() const;
  void set_itemid(::google::protobuf::int32 value);

  // int32 typeID = 2;
  void clear_typeid_();
  static const int kTypeIDFieldNumber = 2;
  ::google::protobuf::int32 typeid_() const;
  void set_typeid_(::google::protobuf::int32 value);

  // int32 count = 3;
  void clear_count();
  static const int kCountFieldNumber = 3;
  ::google::protobuf::int32 count() const;
  void set_count(::google::protobuf::int32 value);

  // int32 overly = 4;
  void clear_overly();
  static const int kOverlyFieldNumber = 4;
  ::google::protobuf::int32 overly() const;
  void set_overly(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GameSpec.CurrencyItem)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 typeid__;
  ::google::protobuf::int32 count_;
  ::google::protobuf::int32 overly_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameSpec_2eproto;
};
// -------------------------------------------------------------------

class BagInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameSpec.BagInfo) */ {
 public:
  BagInfo();
  virtual ~BagInfo();

  BagInfo(const BagInfo& from);

  inline BagInfo& operator=(const BagInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BagInfo(BagInfo&& from) noexcept
    : BagInfo() {
    *this = ::std::move(from);
  }

  inline BagInfo& operator=(BagInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BagInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BagInfo* internal_default_instance() {
    return reinterpret_cast<const BagInfo*>(
               &_BagInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(BagInfo* other);
  friend void swap(BagInfo& a, BagInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BagInfo* New() const final {
    return CreateMaybeMessage<BagInfo>(nullptr);
  }

  BagInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BagInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BagInfo& from);
  void MergeFrom(const BagInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BagInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .GameSpec.BagItem bag = 1;
  int bag_size() const;
  void clear_bag();
  static const int kBagFieldNumber = 1;
  ::GameSpec::BagItem* mutable_bag(int index);
  ::google::protobuf::RepeatedPtrField< ::GameSpec::BagItem >*
      mutable_bag();
  const ::GameSpec::BagItem& bag(int index) const;
  ::GameSpec::BagItem* add_bag();
  const ::google::protobuf::RepeatedPtrField< ::GameSpec::BagItem >&
      bag() const;

  // repeated .GameSpec.EquipItem equipment = 2;
  int equipment_size() const;
  void clear_equipment();
  static const int kEquipmentFieldNumber = 2;
  ::GameSpec::EquipItem* mutable_equipment(int index);
  ::google::protobuf::RepeatedPtrField< ::GameSpec::EquipItem >*
      mutable_equipment();
  const ::GameSpec::EquipItem& equipment(int index) const;
  ::GameSpec::EquipItem* add_equipment();
  const ::google::protobuf::RepeatedPtrField< ::GameSpec::EquipItem >&
      equipment() const;

  // repeated .GameSpec.CurrencyItem currency = 3;
  int currency_size() const;
  void clear_currency();
  static const int kCurrencyFieldNumber = 3;
  ::GameSpec::CurrencyItem* mutable_currency(int index);
  ::google::protobuf::RepeatedPtrField< ::GameSpec::CurrencyItem >*
      mutable_currency();
  const ::GameSpec::CurrencyItem& currency(int index) const;
  ::GameSpec::CurrencyItem* add_currency();
  const ::google::protobuf::RepeatedPtrField< ::GameSpec::CurrencyItem >&
      currency() const;

  // @@protoc_insertion_point(class_scope:GameSpec.BagInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::GameSpec::BagItem > bag_;
  ::google::protobuf::RepeatedPtrField< ::GameSpec::EquipItem > equipment_;
  ::google::protobuf::RepeatedPtrField< ::GameSpec::CurrencyItem > currency_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameSpec_2eproto;
};
// -------------------------------------------------------------------

class Players final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameSpec.Players) */ {
 public:
  Players();
  virtual ~Players();

  Players(const Players& from);

  inline Players& operator=(const Players& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Players(Players&& from) noexcept
    : Players() {
    *this = ::std::move(from);
  }

  inline Players& operator=(Players&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Players& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Players* internal_default_instance() {
    return reinterpret_cast<const Players*>(
               &_Players_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Players* other);
  friend void swap(Players& a, Players& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Players* New() const final {
    return CreateMaybeMessage<Players>(nullptr);
  }

  Players* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Players>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Players& from);
  void MergeFrom(const Players& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Players* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .GameSpec.BagInfo bags = 5;
  bool has_bags() const;
  void clear_bags();
  static const int kBagsFieldNumber = 5;
  const ::GameSpec::BagInfo& bags() const;
  ::GameSpec::BagInfo* release_bags();
  ::GameSpec::BagInfo* mutable_bags();
  void set_allocated_bags(::GameSpec::BagInfo* bags);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // int32 rank = 3;
  void clear_rank();
  static const int kRankFieldNumber = 3;
  ::google::protobuf::int32 rank() const;
  void set_rank(::google::protobuf::int32 value);

  // int32 exp = 4;
  void clear_exp();
  static const int kExpFieldNumber = 4;
  ::google::protobuf::int32 exp() const;
  void set_exp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GameSpec.Players)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::GameSpec::BagInfo* bags_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 rank_;
  ::google::protobuf::int32 exp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameSpec_2eproto;
};
// -------------------------------------------------------------------

class AddItemReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameSpec.AddItemReq) */ {
 public:
  AddItemReq();
  virtual ~AddItemReq();

  AddItemReq(const AddItemReq& from);

  inline AddItemReq& operator=(const AddItemReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddItemReq(AddItemReq&& from) noexcept
    : AddItemReq() {
    *this = ::std::move(from);
  }

  inline AddItemReq& operator=(AddItemReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const AddItemReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddItemReq* internal_default_instance() {
    return reinterpret_cast<const AddItemReq*>(
               &_AddItemReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(AddItemReq* other);
  friend void swap(AddItemReq& a, AddItemReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddItemReq* New() const final {
    return CreateMaybeMessage<AddItemReq>(nullptr);
  }

  AddItemReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddItemReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddItemReq& from);
  void MergeFrom(const AddItemReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddItemReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 itemID = 1;
  void clear_itemid();
  static const int kItemIDFieldNumber = 1;
  ::google::protobuf::int32 itemid() const;
  void set_itemid(::google::protobuf::int32 value);

  // int32 count = 2;
  void clear_count();
  static const int kCountFieldNumber = 2;
  ::google::protobuf::int32 count() const;
  void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GameSpec.AddItemReq)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 count_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameSpec_2eproto;
};
// -------------------------------------------------------------------

class AddItemRsp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameSpec.AddItemRsp) */ {
 public:
  AddItemRsp();
  virtual ~AddItemRsp();

  AddItemRsp(const AddItemRsp& from);

  inline AddItemRsp& operator=(const AddItemRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddItemRsp(AddItemRsp&& from) noexcept
    : AddItemRsp() {
    *this = ::std::move(from);
  }

  inline AddItemRsp& operator=(AddItemRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const AddItemRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddItemRsp* internal_default_instance() {
    return reinterpret_cast<const AddItemRsp*>(
               &_AddItemRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(AddItemRsp* other);
  friend void swap(AddItemRsp& a, AddItemRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddItemRsp* New() const final {
    return CreateMaybeMessage<AddItemRsp>(nullptr);
  }

  AddItemRsp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddItemRsp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddItemRsp& from);
  void MergeFrom(const AddItemRsp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddItemRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .GameSpec.ErrorCode errCode = 1;
  void clear_errcode();
  static const int kErrCodeFieldNumber = 1;
  ::GameSpec::ErrorCode errcode() const;
  void set_errcode(::GameSpec::ErrorCode value);

  // @@protoc_insertion_point(class_scope:GameSpec.AddItemRsp)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int errcode_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameSpec_2eproto;
};
// -------------------------------------------------------------------

class CtlMsgLoginReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameSpec.CtlMsgLoginReq) */ {
 public:
  CtlMsgLoginReq();
  virtual ~CtlMsgLoginReq();

  CtlMsgLoginReq(const CtlMsgLoginReq& from);

  inline CtlMsgLoginReq& operator=(const CtlMsgLoginReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CtlMsgLoginReq(CtlMsgLoginReq&& from) noexcept
    : CtlMsgLoginReq() {
    *this = ::std::move(from);
  }

  inline CtlMsgLoginReq& operator=(CtlMsgLoginReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CtlMsgLoginReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CtlMsgLoginReq* internal_default_instance() {
    return reinterpret_cast<const CtlMsgLoginReq*>(
               &_CtlMsgLoginReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(CtlMsgLoginReq* other);
  friend void swap(CtlMsgLoginReq& a, CtlMsgLoginReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CtlMsgLoginReq* New() const final {
    return CreateMaybeMessage<CtlMsgLoginReq>(nullptr);
  }

  CtlMsgLoginReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CtlMsgLoginReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CtlMsgLoginReq& from);
  void MergeFrom(const CtlMsgLoginReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CtlMsgLoginReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string Name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string password = 2;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:GameSpec.CtlMsgLoginReq)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameSpec_2eproto;
};
// -------------------------------------------------------------------

class CtlMsgLoginRsp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameSpec.CtlMsgLoginRsp) */ {
 public:
  CtlMsgLoginRsp();
  virtual ~CtlMsgLoginRsp();

  CtlMsgLoginRsp(const CtlMsgLoginRsp& from);

  inline CtlMsgLoginRsp& operator=(const CtlMsgLoginRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CtlMsgLoginRsp(CtlMsgLoginRsp&& from) noexcept
    : CtlMsgLoginRsp() {
    *this = ::std::move(from);
  }

  inline CtlMsgLoginRsp& operator=(CtlMsgLoginRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CtlMsgLoginRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CtlMsgLoginRsp* internal_default_instance() {
    return reinterpret_cast<const CtlMsgLoginRsp*>(
               &_CtlMsgLoginRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(CtlMsgLoginRsp* other);
  friend void swap(CtlMsgLoginRsp& a, CtlMsgLoginRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CtlMsgLoginRsp* New() const final {
    return CreateMaybeMessage<CtlMsgLoginRsp>(nullptr);
  }

  CtlMsgLoginRsp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CtlMsgLoginRsp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CtlMsgLoginRsp& from);
  void MergeFrom(const CtlMsgLoginRsp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CtlMsgLoginRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .GameSpec.Players player = 2;
  bool has_player() const;
  void clear_player();
  static const int kPlayerFieldNumber = 2;
  const ::GameSpec::Players& player() const;
  ::GameSpec::Players* release_player();
  ::GameSpec::Players* mutable_player();
  void set_allocated_player(::GameSpec::Players* player);

  // .GameSpec.ErrorCode errCode = 1;
  void clear_errcode();
  static const int kErrCodeFieldNumber = 1;
  ::GameSpec::ErrorCode errcode() const;
  void set_errcode(::GameSpec::ErrorCode value);

  // @@protoc_insertion_point(class_scope:GameSpec.CtlMsgLoginRsp)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::GameSpec::Players* player_;
  int errcode_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameSpec_2eproto;
};
// -------------------------------------------------------------------

class CtlMsgSearchReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameSpec.CtlMsgSearchReq) */ {
 public:
  CtlMsgSearchReq();
  virtual ~CtlMsgSearchReq();

  CtlMsgSearchReq(const CtlMsgSearchReq& from);

  inline CtlMsgSearchReq& operator=(const CtlMsgSearchReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CtlMsgSearchReq(CtlMsgSearchReq&& from) noexcept
    : CtlMsgSearchReq() {
    *this = ::std::move(from);
  }

  inline CtlMsgSearchReq& operator=(CtlMsgSearchReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CtlMsgSearchReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CtlMsgSearchReq* internal_default_instance() {
    return reinterpret_cast<const CtlMsgSearchReq*>(
               &_CtlMsgSearchReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(CtlMsgSearchReq* other);
  friend void swap(CtlMsgSearchReq& a, CtlMsgSearchReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CtlMsgSearchReq* New() const final {
    return CreateMaybeMessage<CtlMsgSearchReq>(nullptr);
  }

  CtlMsgSearchReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CtlMsgSearchReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CtlMsgSearchReq& from);
  void MergeFrom(const CtlMsgSearchReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CtlMsgSearchReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string Name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GameSpec.CtlMsgSearchReq)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameSpec_2eproto;
};
// -------------------------------------------------------------------

class CtlMsgSearchRsp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameSpec.CtlMsgSearchRsp) */ {
 public:
  CtlMsgSearchRsp();
  virtual ~CtlMsgSearchRsp();

  CtlMsgSearchRsp(const CtlMsgSearchRsp& from);

  inline CtlMsgSearchRsp& operator=(const CtlMsgSearchRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CtlMsgSearchRsp(CtlMsgSearchRsp&& from) noexcept
    : CtlMsgSearchRsp() {
    *this = ::std::move(from);
  }

  inline CtlMsgSearchRsp& operator=(CtlMsgSearchRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CtlMsgSearchRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CtlMsgSearchRsp* internal_default_instance() {
    return reinterpret_cast<const CtlMsgSearchRsp*>(
               &_CtlMsgSearchRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(CtlMsgSearchRsp* other);
  friend void swap(CtlMsgSearchRsp& a, CtlMsgSearchRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CtlMsgSearchRsp* New() const final {
    return CreateMaybeMessage<CtlMsgSearchRsp>(nullptr);
  }

  CtlMsgSearchRsp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CtlMsgSearchRsp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CtlMsgSearchRsp& from);
  void MergeFrom(const CtlMsgSearchRsp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CtlMsgSearchRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .GameSpec.Players player = 2;
  bool has_player() const;
  void clear_player();
  static const int kPlayerFieldNumber = 2;
  const ::GameSpec::Players& player() const;
  ::GameSpec::Players* release_player();
  ::GameSpec::Players* mutable_player();
  void set_allocated_player(::GameSpec::Players* player);

  // .GameSpec.ErrorCode errCode = 1;
  void clear_errcode();
  static const int kErrCodeFieldNumber = 1;
  ::GameSpec::ErrorCode errcode() const;
  void set_errcode(::GameSpec::ErrorCode value);

  // @@protoc_insertion_point(class_scope:GameSpec.CtlMsgSearchRsp)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::GameSpec::Players* player_;
  int errcode_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameSpec_2eproto;
};
// -------------------------------------------------------------------

class RemoveItemReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameSpec.RemoveItemReq) */ {
 public:
  RemoveItemReq();
  virtual ~RemoveItemReq();

  RemoveItemReq(const RemoveItemReq& from);

  inline RemoveItemReq& operator=(const RemoveItemReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RemoveItemReq(RemoveItemReq&& from) noexcept
    : RemoveItemReq() {
    *this = ::std::move(from);
  }

  inline RemoveItemReq& operator=(RemoveItemReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RemoveItemReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RemoveItemReq* internal_default_instance() {
    return reinterpret_cast<const RemoveItemReq*>(
               &_RemoveItemReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(RemoveItemReq* other);
  friend void swap(RemoveItemReq& a, RemoveItemReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RemoveItemReq* New() const final {
    return CreateMaybeMessage<RemoveItemReq>(nullptr);
  }

  RemoveItemReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RemoveItemReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RemoveItemReq& from);
  void MergeFrom(const RemoveItemReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveItemReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 itemID = 1;
  void clear_itemid();
  static const int kItemIDFieldNumber = 1;
  ::google::protobuf::int32 itemid() const;
  void set_itemid(::google::protobuf::int32 value);

  // int32 count = 2;
  void clear_count();
  static const int kCountFieldNumber = 2;
  ::google::protobuf::int32 count() const;
  void set_count(::google::protobuf::int32 value);

  // int32 pos = 3;
  void clear_pos();
  static const int kPosFieldNumber = 3;
  ::google::protobuf::int32 pos() const;
  void set_pos(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GameSpec.RemoveItemReq)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 count_;
  ::google::protobuf::int32 pos_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameSpec_2eproto;
};
// -------------------------------------------------------------------

class RemoveItemRsp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameSpec.RemoveItemRsp) */ {
 public:
  RemoveItemRsp();
  virtual ~RemoveItemRsp();

  RemoveItemRsp(const RemoveItemRsp& from);

  inline RemoveItemRsp& operator=(const RemoveItemRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RemoveItemRsp(RemoveItemRsp&& from) noexcept
    : RemoveItemRsp() {
    *this = ::std::move(from);
  }

  inline RemoveItemRsp& operator=(RemoveItemRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RemoveItemRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RemoveItemRsp* internal_default_instance() {
    return reinterpret_cast<const RemoveItemRsp*>(
               &_RemoveItemRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(RemoveItemRsp* other);
  friend void swap(RemoveItemRsp& a, RemoveItemRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RemoveItemRsp* New() const final {
    return CreateMaybeMessage<RemoveItemRsp>(nullptr);
  }

  RemoveItemRsp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RemoveItemRsp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RemoveItemRsp& from);
  void MergeFrom(const RemoveItemRsp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveItemRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .GameSpec.ErrorCode errCode = 1;
  void clear_errcode();
  static const int kErrCodeFieldNumber = 1;
  ::GameSpec::ErrorCode errcode() const;
  void set_errcode(::GameSpec::ErrorCode value);

  // @@protoc_insertion_point(class_scope:GameSpec.RemoveItemRsp)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int errcode_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameSpec_2eproto;
};
// -------------------------------------------------------------------

class RankReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameSpec.RankReq) */ {
 public:
  RankReq();
  virtual ~RankReq();

  RankReq(const RankReq& from);

  inline RankReq& operator=(const RankReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RankReq(RankReq&& from) noexcept
    : RankReq() {
    *this = ::std::move(from);
  }

  inline RankReq& operator=(RankReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RankReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RankReq* internal_default_instance() {
    return reinterpret_cast<const RankReq*>(
               &_RankReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(RankReq* other);
  friend void swap(RankReq& a, RankReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RankReq* New() const final {
    return CreateMaybeMessage<RankReq>(nullptr);
  }

  RankReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RankReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RankReq& from);
  void MergeFrom(const RankReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RankReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 start = 1;
  void clear_start();
  static const int kStartFieldNumber = 1;
  ::google::protobuf::int32 start() const;
  void set_start(::google::protobuf::int32 value);

  // int32 end = 2;
  void clear_end();
  static const int kEndFieldNumber = 2;
  ::google::protobuf::int32 end() const;
  void set_end(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GameSpec.RankReq)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 start_;
  ::google::protobuf::int32 end_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameSpec_2eproto;
};
// -------------------------------------------------------------------

class RankRsp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GameSpec.RankRsp) */ {
 public:
  RankRsp();
  virtual ~RankRsp();

  RankRsp(const RankRsp& from);

  inline RankRsp& operator=(const RankRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RankRsp(RankRsp&& from) noexcept
    : RankRsp() {
    *this = ::std::move(from);
  }

  inline RankRsp& operator=(RankRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RankRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RankRsp* internal_default_instance() {
    return reinterpret_cast<const RankRsp*>(
               &_RankRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(RankRsp* other);
  friend void swap(RankRsp& a, RankRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RankRsp* New() const final {
    return CreateMaybeMessage<RankRsp>(nullptr);
  }

  RankRsp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RankRsp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RankRsp& from);
  void MergeFrom(const RankRsp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RankRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string name = 2;
  int name_size() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name(int index) const;
  ::std::string* mutable_name(int index);
  void set_name(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_name(int index, ::std::string&& value);
  #endif
  void set_name(int index, const char* value);
  void set_name(int index, const char* value, size_t size);
  ::std::string* add_name();
  void add_name(const ::std::string& value);
  #if LANG_CXX11
  void add_name(::std::string&& value);
  #endif
  void add_name(const char* value);
  void add_name(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& name() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_name();

  // repeated int32 exp = 3;
  int exp_size() const;
  void clear_exp();
  static const int kExpFieldNumber = 3;
  ::google::protobuf::int32 exp(int index) const;
  void set_exp(int index, ::google::protobuf::int32 value);
  void add_exp(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      exp() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_exp();

  // .GameSpec.ErrorCode errCode = 1;
  void clear_errcode();
  static const int kErrCodeFieldNumber = 1;
  ::GameSpec::ErrorCode errcode() const;
  void set_errcode(::GameSpec::ErrorCode value);

  // @@protoc_insertion_point(class_scope:GameSpec.RankRsp)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > exp_;
  mutable std::atomic<int> _exp_cached_byte_size_;
  int errcode_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_GameSpec_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BagItem

// int32 itemID = 1;
inline void BagItem::clear_itemid() {
  itemid_ = 0;
}
inline ::google::protobuf::int32 BagItem::itemid() const {
  // @@protoc_insertion_point(field_get:GameSpec.BagItem.itemID)
  return itemid_;
}
inline void BagItem::set_itemid(::google::protobuf::int32 value) {
  
  itemid_ = value;
  // @@protoc_insertion_point(field_set:GameSpec.BagItem.itemID)
}

// int32 typeID = 2;
inline void BagItem::clear_typeid_() {
  typeid__ = 0;
}
inline ::google::protobuf::int32 BagItem::typeid_() const {
  // @@protoc_insertion_point(field_get:GameSpec.BagItem.typeID)
  return typeid__;
}
inline void BagItem::set_typeid_(::google::protobuf::int32 value) {
  
  typeid__ = value;
  // @@protoc_insertion_point(field_set:GameSpec.BagItem.typeID)
}

// int32 count = 3;
inline void BagItem::clear_count() {
  count_ = 0;
}
inline ::google::protobuf::int32 BagItem::count() const {
  // @@protoc_insertion_point(field_get:GameSpec.BagItem.count)
  return count_;
}
inline void BagItem::set_count(::google::protobuf::int32 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:GameSpec.BagItem.count)
}

// int32 overly = 4;
inline void BagItem::clear_overly() {
  overly_ = 0;
}
inline ::google::protobuf::int32 BagItem::overly() const {
  // @@protoc_insertion_point(field_get:GameSpec.BagItem.overly)
  return overly_;
}
inline void BagItem::set_overly(::google::protobuf::int32 value) {
  
  overly_ = value;
  // @@protoc_insertion_point(field_set:GameSpec.BagItem.overly)
}

// bool binded = 5;
inline void BagItem::clear_binded() {
  binded_ = false;
}
inline bool BagItem::binded() const {
  // @@protoc_insertion_point(field_get:GameSpec.BagItem.binded)
  return binded_;
}
inline void BagItem::set_binded(bool value) {
  
  binded_ = value;
  // @@protoc_insertion_point(field_set:GameSpec.BagItem.binded)
}

// -------------------------------------------------------------------

// EquipItem

// int32 itemID = 1;
inline void EquipItem::clear_itemid() {
  itemid_ = 0;
}
inline ::google::protobuf::int32 EquipItem::itemid() const {
  // @@protoc_insertion_point(field_get:GameSpec.EquipItem.itemID)
  return itemid_;
}
inline void EquipItem::set_itemid(::google::protobuf::int32 value) {
  
  itemid_ = value;
  // @@protoc_insertion_point(field_set:GameSpec.EquipItem.itemID)
}

// int32 typeID = 2;
inline void EquipItem::clear_typeid_() {
  typeid__ = 0;
}
inline ::google::protobuf::int32 EquipItem::typeid_() const {
  // @@protoc_insertion_point(field_get:GameSpec.EquipItem.typeID)
  return typeid__;
}
inline void EquipItem::set_typeid_(::google::protobuf::int32 value) {
  
  typeid__ = value;
  // @@protoc_insertion_point(field_set:GameSpec.EquipItem.typeID)
}

// int32 count = 3;
inline void EquipItem::clear_count() {
  count_ = 0;
}
inline ::google::protobuf::int32 EquipItem::count() const {
  // @@protoc_insertion_point(field_get:GameSpec.EquipItem.count)
  return count_;
}
inline void EquipItem::set_count(::google::protobuf::int32 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:GameSpec.EquipItem.count)
}

// int32 overly = 4;
inline void EquipItem::clear_overly() {
  overly_ = 0;
}
inline ::google::protobuf::int32 EquipItem::overly() const {
  // @@protoc_insertion_point(field_get:GameSpec.EquipItem.overly)
  return overly_;
}
inline void EquipItem::set_overly(::google::protobuf::int32 value) {
  
  overly_ = value;
  // @@protoc_insertion_point(field_set:GameSpec.EquipItem.overly)
}

// bool binded = 5;
inline void EquipItem::clear_binded() {
  binded_ = false;
}
inline bool EquipItem::binded() const {
  // @@protoc_insertion_point(field_get:GameSpec.EquipItem.binded)
  return binded_;
}
inline void EquipItem::set_binded(bool value) {
  
  binded_ = value;
  // @@protoc_insertion_point(field_set:GameSpec.EquipItem.binded)
}

// int32 attack = 6;
inline void EquipItem::clear_attack() {
  attack_ = 0;
}
inline ::google::protobuf::int32 EquipItem::attack() const {
  // @@protoc_insertion_point(field_get:GameSpec.EquipItem.attack)
  return attack_;
}
inline void EquipItem::set_attack(::google::protobuf::int32 value) {
  
  attack_ = value;
  // @@protoc_insertion_point(field_set:GameSpec.EquipItem.attack)
}

// int32 durability = 7;
inline void EquipItem::clear_durability() {
  durability_ = 0;
}
inline ::google::protobuf::int32 EquipItem::durability() const {
  // @@protoc_insertion_point(field_get:GameSpec.EquipItem.durability)
  return durability_;
}
inline void EquipItem::set_durability(::google::protobuf::int32 value) {
  
  durability_ = value;
  // @@protoc_insertion_point(field_set:GameSpec.EquipItem.durability)
}

// -------------------------------------------------------------------

// CurrencyItem

// int32 itemID = 1;
inline void CurrencyItem::clear_itemid() {
  itemid_ = 0;
}
inline ::google::protobuf::int32 CurrencyItem::itemid() const {
  // @@protoc_insertion_point(field_get:GameSpec.CurrencyItem.itemID)
  return itemid_;
}
inline void CurrencyItem::set_itemid(::google::protobuf::int32 value) {
  
  itemid_ = value;
  // @@protoc_insertion_point(field_set:GameSpec.CurrencyItem.itemID)
}

// int32 typeID = 2;
inline void CurrencyItem::clear_typeid_() {
  typeid__ = 0;
}
inline ::google::protobuf::int32 CurrencyItem::typeid_() const {
  // @@protoc_insertion_point(field_get:GameSpec.CurrencyItem.typeID)
  return typeid__;
}
inline void CurrencyItem::set_typeid_(::google::protobuf::int32 value) {
  
  typeid__ = value;
  // @@protoc_insertion_point(field_set:GameSpec.CurrencyItem.typeID)
}

// int32 count = 3;
inline void CurrencyItem::clear_count() {
  count_ = 0;
}
inline ::google::protobuf::int32 CurrencyItem::count() const {
  // @@protoc_insertion_point(field_get:GameSpec.CurrencyItem.count)
  return count_;
}
inline void CurrencyItem::set_count(::google::protobuf::int32 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:GameSpec.CurrencyItem.count)
}

// int32 overly = 4;
inline void CurrencyItem::clear_overly() {
  overly_ = 0;
}
inline ::google::protobuf::int32 CurrencyItem::overly() const {
  // @@protoc_insertion_point(field_get:GameSpec.CurrencyItem.overly)
  return overly_;
}
inline void CurrencyItem::set_overly(::google::protobuf::int32 value) {
  
  overly_ = value;
  // @@protoc_insertion_point(field_set:GameSpec.CurrencyItem.overly)
}

// -------------------------------------------------------------------

// BagInfo

// repeated .GameSpec.BagItem bag = 1;
inline int BagInfo::bag_size() const {
  return bag_.size();
}
inline void BagInfo::clear_bag() {
  bag_.Clear();
}
inline ::GameSpec::BagItem* BagInfo::mutable_bag(int index) {
  // @@protoc_insertion_point(field_mutable:GameSpec.BagInfo.bag)
  return bag_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::GameSpec::BagItem >*
BagInfo::mutable_bag() {
  // @@protoc_insertion_point(field_mutable_list:GameSpec.BagInfo.bag)
  return &bag_;
}
inline const ::GameSpec::BagItem& BagInfo::bag(int index) const {
  // @@protoc_insertion_point(field_get:GameSpec.BagInfo.bag)
  return bag_.Get(index);
}
inline ::GameSpec::BagItem* BagInfo::add_bag() {
  // @@protoc_insertion_point(field_add:GameSpec.BagInfo.bag)
  return bag_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GameSpec::BagItem >&
BagInfo::bag() const {
  // @@protoc_insertion_point(field_list:GameSpec.BagInfo.bag)
  return bag_;
}

// repeated .GameSpec.EquipItem equipment = 2;
inline int BagInfo::equipment_size() const {
  return equipment_.size();
}
inline void BagInfo::clear_equipment() {
  equipment_.Clear();
}
inline ::GameSpec::EquipItem* BagInfo::mutable_equipment(int index) {
  // @@protoc_insertion_point(field_mutable:GameSpec.BagInfo.equipment)
  return equipment_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::GameSpec::EquipItem >*
BagInfo::mutable_equipment() {
  // @@protoc_insertion_point(field_mutable_list:GameSpec.BagInfo.equipment)
  return &equipment_;
}
inline const ::GameSpec::EquipItem& BagInfo::equipment(int index) const {
  // @@protoc_insertion_point(field_get:GameSpec.BagInfo.equipment)
  return equipment_.Get(index);
}
inline ::GameSpec::EquipItem* BagInfo::add_equipment() {
  // @@protoc_insertion_point(field_add:GameSpec.BagInfo.equipment)
  return equipment_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GameSpec::EquipItem >&
BagInfo::equipment() const {
  // @@protoc_insertion_point(field_list:GameSpec.BagInfo.equipment)
  return equipment_;
}

// repeated .GameSpec.CurrencyItem currency = 3;
inline int BagInfo::currency_size() const {
  return currency_.size();
}
inline void BagInfo::clear_currency() {
  currency_.Clear();
}
inline ::GameSpec::CurrencyItem* BagInfo::mutable_currency(int index) {
  // @@protoc_insertion_point(field_mutable:GameSpec.BagInfo.currency)
  return currency_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::GameSpec::CurrencyItem >*
BagInfo::mutable_currency() {
  // @@protoc_insertion_point(field_mutable_list:GameSpec.BagInfo.currency)
  return &currency_;
}
inline const ::GameSpec::CurrencyItem& BagInfo::currency(int index) const {
  // @@protoc_insertion_point(field_get:GameSpec.BagInfo.currency)
  return currency_.Get(index);
}
inline ::GameSpec::CurrencyItem* BagInfo::add_currency() {
  // @@protoc_insertion_point(field_add:GameSpec.BagInfo.currency)
  return currency_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GameSpec::CurrencyItem >&
BagInfo::currency() const {
  // @@protoc_insertion_point(field_list:GameSpec.BagInfo.currency)
  return currency_;
}

// -------------------------------------------------------------------

// Players

// int32 id = 1;
inline void Players::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 Players::id() const {
  // @@protoc_insertion_point(field_get:GameSpec.Players.id)
  return id_;
}
inline void Players::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:GameSpec.Players.id)
}

// string name = 2;
inline void Players::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Players::name() const {
  // @@protoc_insertion_point(field_get:GameSpec.Players.name)
  return name_.GetNoArena();
}
inline void Players::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GameSpec.Players.name)
}
#if LANG_CXX11
inline void Players::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GameSpec.Players.name)
}
#endif
inline void Players::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GameSpec.Players.name)
}
inline void Players::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GameSpec.Players.name)
}
inline ::std::string* Players::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:GameSpec.Players.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Players::release_name() {
  // @@protoc_insertion_point(field_release:GameSpec.Players.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Players::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:GameSpec.Players.name)
}

// int32 rank = 3;
inline void Players::clear_rank() {
  rank_ = 0;
}
inline ::google::protobuf::int32 Players::rank() const {
  // @@protoc_insertion_point(field_get:GameSpec.Players.rank)
  return rank_;
}
inline void Players::set_rank(::google::protobuf::int32 value) {
  
  rank_ = value;
  // @@protoc_insertion_point(field_set:GameSpec.Players.rank)
}

// int32 exp = 4;
inline void Players::clear_exp() {
  exp_ = 0;
}
inline ::google::protobuf::int32 Players::exp() const {
  // @@protoc_insertion_point(field_get:GameSpec.Players.exp)
  return exp_;
}
inline void Players::set_exp(::google::protobuf::int32 value) {
  
  exp_ = value;
  // @@protoc_insertion_point(field_set:GameSpec.Players.exp)
}

// .GameSpec.BagInfo bags = 5;
inline bool Players::has_bags() const {
  return this != internal_default_instance() && bags_ != nullptr;
}
inline void Players::clear_bags() {
  if (GetArenaNoVirtual() == nullptr && bags_ != nullptr) {
    delete bags_;
  }
  bags_ = nullptr;
}
inline const ::GameSpec::BagInfo& Players::bags() const {
  const ::GameSpec::BagInfo* p = bags_;
  // @@protoc_insertion_point(field_get:GameSpec.Players.bags)
  return p != nullptr ? *p : *reinterpret_cast<const ::GameSpec::BagInfo*>(
      &::GameSpec::_BagInfo_default_instance_);
}
inline ::GameSpec::BagInfo* Players::release_bags() {
  // @@protoc_insertion_point(field_release:GameSpec.Players.bags)
  
  ::GameSpec::BagInfo* temp = bags_;
  bags_ = nullptr;
  return temp;
}
inline ::GameSpec::BagInfo* Players::mutable_bags() {
  
  if (bags_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameSpec::BagInfo>(GetArenaNoVirtual());
    bags_ = p;
  }
  // @@protoc_insertion_point(field_mutable:GameSpec.Players.bags)
  return bags_;
}
inline void Players::set_allocated_bags(::GameSpec::BagInfo* bags) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete bags_;
  }
  if (bags) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      bags = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bags, submessage_arena);
    }
    
  } else {
    
  }
  bags_ = bags;
  // @@protoc_insertion_point(field_set_allocated:GameSpec.Players.bags)
}

// -------------------------------------------------------------------

// AddItemReq

// int32 itemID = 1;
inline void AddItemReq::clear_itemid() {
  itemid_ = 0;
}
inline ::google::protobuf::int32 AddItemReq::itemid() const {
  // @@protoc_insertion_point(field_get:GameSpec.AddItemReq.itemID)
  return itemid_;
}
inline void AddItemReq::set_itemid(::google::protobuf::int32 value) {
  
  itemid_ = value;
  // @@protoc_insertion_point(field_set:GameSpec.AddItemReq.itemID)
}

// int32 count = 2;
inline void AddItemReq::clear_count() {
  count_ = 0;
}
inline ::google::protobuf::int32 AddItemReq::count() const {
  // @@protoc_insertion_point(field_get:GameSpec.AddItemReq.count)
  return count_;
}
inline void AddItemReq::set_count(::google::protobuf::int32 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:GameSpec.AddItemReq.count)
}

// -------------------------------------------------------------------

// AddItemRsp

// .GameSpec.ErrorCode errCode = 1;
inline void AddItemRsp::clear_errcode() {
  errcode_ = 0;
}
inline ::GameSpec::ErrorCode AddItemRsp::errcode() const {
  // @@protoc_insertion_point(field_get:GameSpec.AddItemRsp.errCode)
  return static_cast< ::GameSpec::ErrorCode >(errcode_);
}
inline void AddItemRsp::set_errcode(::GameSpec::ErrorCode value) {
  
  errcode_ = value;
  // @@protoc_insertion_point(field_set:GameSpec.AddItemRsp.errCode)
}

// -------------------------------------------------------------------

// CtlMsgLoginReq

// string Name = 1;
inline void CtlMsgLoginReq::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CtlMsgLoginReq::name() const {
  // @@protoc_insertion_point(field_get:GameSpec.CtlMsgLoginReq.Name)
  return name_.GetNoArena();
}
inline void CtlMsgLoginReq::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GameSpec.CtlMsgLoginReq.Name)
}
#if LANG_CXX11
inline void CtlMsgLoginReq::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GameSpec.CtlMsgLoginReq.Name)
}
#endif
inline void CtlMsgLoginReq::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GameSpec.CtlMsgLoginReq.Name)
}
inline void CtlMsgLoginReq::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GameSpec.CtlMsgLoginReq.Name)
}
inline ::std::string* CtlMsgLoginReq::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:GameSpec.CtlMsgLoginReq.Name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CtlMsgLoginReq::release_name() {
  // @@protoc_insertion_point(field_release:GameSpec.CtlMsgLoginReq.Name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CtlMsgLoginReq::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:GameSpec.CtlMsgLoginReq.Name)
}

// string password = 2;
inline void CtlMsgLoginReq::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CtlMsgLoginReq::password() const {
  // @@protoc_insertion_point(field_get:GameSpec.CtlMsgLoginReq.password)
  return password_.GetNoArena();
}
inline void CtlMsgLoginReq::set_password(const ::std::string& value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GameSpec.CtlMsgLoginReq.password)
}
#if LANG_CXX11
inline void CtlMsgLoginReq::set_password(::std::string&& value) {
  
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GameSpec.CtlMsgLoginReq.password)
}
#endif
inline void CtlMsgLoginReq::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GameSpec.CtlMsgLoginReq.password)
}
inline void CtlMsgLoginReq::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GameSpec.CtlMsgLoginReq.password)
}
inline ::std::string* CtlMsgLoginReq::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:GameSpec.CtlMsgLoginReq.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CtlMsgLoginReq::release_password() {
  // @@protoc_insertion_point(field_release:GameSpec.CtlMsgLoginReq.password)
  
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CtlMsgLoginReq::set_allocated_password(::std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:GameSpec.CtlMsgLoginReq.password)
}

// -------------------------------------------------------------------

// CtlMsgLoginRsp

// .GameSpec.ErrorCode errCode = 1;
inline void CtlMsgLoginRsp::clear_errcode() {
  errcode_ = 0;
}
inline ::GameSpec::ErrorCode CtlMsgLoginRsp::errcode() const {
  // @@protoc_insertion_point(field_get:GameSpec.CtlMsgLoginRsp.errCode)
  return static_cast< ::GameSpec::ErrorCode >(errcode_);
}
inline void CtlMsgLoginRsp::set_errcode(::GameSpec::ErrorCode value) {
  
  errcode_ = value;
  // @@protoc_insertion_point(field_set:GameSpec.CtlMsgLoginRsp.errCode)
}

// .GameSpec.Players player = 2;
inline bool CtlMsgLoginRsp::has_player() const {
  return this != internal_default_instance() && player_ != nullptr;
}
inline void CtlMsgLoginRsp::clear_player() {
  if (GetArenaNoVirtual() == nullptr && player_ != nullptr) {
    delete player_;
  }
  player_ = nullptr;
}
inline const ::GameSpec::Players& CtlMsgLoginRsp::player() const {
  const ::GameSpec::Players* p = player_;
  // @@protoc_insertion_point(field_get:GameSpec.CtlMsgLoginRsp.player)
  return p != nullptr ? *p : *reinterpret_cast<const ::GameSpec::Players*>(
      &::GameSpec::_Players_default_instance_);
}
inline ::GameSpec::Players* CtlMsgLoginRsp::release_player() {
  // @@protoc_insertion_point(field_release:GameSpec.CtlMsgLoginRsp.player)
  
  ::GameSpec::Players* temp = player_;
  player_ = nullptr;
  return temp;
}
inline ::GameSpec::Players* CtlMsgLoginRsp::mutable_player() {
  
  if (player_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameSpec::Players>(GetArenaNoVirtual());
    player_ = p;
  }
  // @@protoc_insertion_point(field_mutable:GameSpec.CtlMsgLoginRsp.player)
  return player_;
}
inline void CtlMsgLoginRsp::set_allocated_player(::GameSpec::Players* player) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete player_;
  }
  if (player) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      player = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  player_ = player;
  // @@protoc_insertion_point(field_set_allocated:GameSpec.CtlMsgLoginRsp.player)
}

// -------------------------------------------------------------------

// CtlMsgSearchReq

// int32 id = 1;
inline void CtlMsgSearchReq::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 CtlMsgSearchReq::id() const {
  // @@protoc_insertion_point(field_get:GameSpec.CtlMsgSearchReq.id)
  return id_;
}
inline void CtlMsgSearchReq::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:GameSpec.CtlMsgSearchReq.id)
}

// string Name = 2;
inline void CtlMsgSearchReq::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CtlMsgSearchReq::name() const {
  // @@protoc_insertion_point(field_get:GameSpec.CtlMsgSearchReq.Name)
  return name_.GetNoArena();
}
inline void CtlMsgSearchReq::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:GameSpec.CtlMsgSearchReq.Name)
}
#if LANG_CXX11
inline void CtlMsgSearchReq::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GameSpec.CtlMsgSearchReq.Name)
}
#endif
inline void CtlMsgSearchReq::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GameSpec.CtlMsgSearchReq.Name)
}
inline void CtlMsgSearchReq::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GameSpec.CtlMsgSearchReq.Name)
}
inline ::std::string* CtlMsgSearchReq::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:GameSpec.CtlMsgSearchReq.Name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CtlMsgSearchReq::release_name() {
  // @@protoc_insertion_point(field_release:GameSpec.CtlMsgSearchReq.Name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CtlMsgSearchReq::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:GameSpec.CtlMsgSearchReq.Name)
}

// -------------------------------------------------------------------

// CtlMsgSearchRsp

// .GameSpec.ErrorCode errCode = 1;
inline void CtlMsgSearchRsp::clear_errcode() {
  errcode_ = 0;
}
inline ::GameSpec::ErrorCode CtlMsgSearchRsp::errcode() const {
  // @@protoc_insertion_point(field_get:GameSpec.CtlMsgSearchRsp.errCode)
  return static_cast< ::GameSpec::ErrorCode >(errcode_);
}
inline void CtlMsgSearchRsp::set_errcode(::GameSpec::ErrorCode value) {
  
  errcode_ = value;
  // @@protoc_insertion_point(field_set:GameSpec.CtlMsgSearchRsp.errCode)
}

// .GameSpec.Players player = 2;
inline bool CtlMsgSearchRsp::has_player() const {
  return this != internal_default_instance() && player_ != nullptr;
}
inline void CtlMsgSearchRsp::clear_player() {
  if (GetArenaNoVirtual() == nullptr && player_ != nullptr) {
    delete player_;
  }
  player_ = nullptr;
}
inline const ::GameSpec::Players& CtlMsgSearchRsp::player() const {
  const ::GameSpec::Players* p = player_;
  // @@protoc_insertion_point(field_get:GameSpec.CtlMsgSearchRsp.player)
  return p != nullptr ? *p : *reinterpret_cast<const ::GameSpec::Players*>(
      &::GameSpec::_Players_default_instance_);
}
inline ::GameSpec::Players* CtlMsgSearchRsp::release_player() {
  // @@protoc_insertion_point(field_release:GameSpec.CtlMsgSearchRsp.player)
  
  ::GameSpec::Players* temp = player_;
  player_ = nullptr;
  return temp;
}
inline ::GameSpec::Players* CtlMsgSearchRsp::mutable_player() {
  
  if (player_ == nullptr) {
    auto* p = CreateMaybeMessage<::GameSpec::Players>(GetArenaNoVirtual());
    player_ = p;
  }
  // @@protoc_insertion_point(field_mutable:GameSpec.CtlMsgSearchRsp.player)
  return player_;
}
inline void CtlMsgSearchRsp::set_allocated_player(::GameSpec::Players* player) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete player_;
  }
  if (player) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      player = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    
  } else {
    
  }
  player_ = player;
  // @@protoc_insertion_point(field_set_allocated:GameSpec.CtlMsgSearchRsp.player)
}

// -------------------------------------------------------------------

// RemoveItemReq

// int32 itemID = 1;
inline void RemoveItemReq::clear_itemid() {
  itemid_ = 0;
}
inline ::google::protobuf::int32 RemoveItemReq::itemid() const {
  // @@protoc_insertion_point(field_get:GameSpec.RemoveItemReq.itemID)
  return itemid_;
}
inline void RemoveItemReq::set_itemid(::google::protobuf::int32 value) {
  
  itemid_ = value;
  // @@protoc_insertion_point(field_set:GameSpec.RemoveItemReq.itemID)
}

// int32 count = 2;
inline void RemoveItemReq::clear_count() {
  count_ = 0;
}
inline ::google::protobuf::int32 RemoveItemReq::count() const {
  // @@protoc_insertion_point(field_get:GameSpec.RemoveItemReq.count)
  return count_;
}
inline void RemoveItemReq::set_count(::google::protobuf::int32 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:GameSpec.RemoveItemReq.count)
}

// int32 pos = 3;
inline void RemoveItemReq::clear_pos() {
  pos_ = 0;
}
inline ::google::protobuf::int32 RemoveItemReq::pos() const {
  // @@protoc_insertion_point(field_get:GameSpec.RemoveItemReq.pos)
  return pos_;
}
inline void RemoveItemReq::set_pos(::google::protobuf::int32 value) {
  
  pos_ = value;
  // @@protoc_insertion_point(field_set:GameSpec.RemoveItemReq.pos)
}

// -------------------------------------------------------------------

// RemoveItemRsp

// .GameSpec.ErrorCode errCode = 1;
inline void RemoveItemRsp::clear_errcode() {
  errcode_ = 0;
}
inline ::GameSpec::ErrorCode RemoveItemRsp::errcode() const {
  // @@protoc_insertion_point(field_get:GameSpec.RemoveItemRsp.errCode)
  return static_cast< ::GameSpec::ErrorCode >(errcode_);
}
inline void RemoveItemRsp::set_errcode(::GameSpec::ErrorCode value) {
  
  errcode_ = value;
  // @@protoc_insertion_point(field_set:GameSpec.RemoveItemRsp.errCode)
}

// -------------------------------------------------------------------

// RankReq

// int32 start = 1;
inline void RankReq::clear_start() {
  start_ = 0;
}
inline ::google::protobuf::int32 RankReq::start() const {
  // @@protoc_insertion_point(field_get:GameSpec.RankReq.start)
  return start_;
}
inline void RankReq::set_start(::google::protobuf::int32 value) {
  
  start_ = value;
  // @@protoc_insertion_point(field_set:GameSpec.RankReq.start)
}

// int32 end = 2;
inline void RankReq::clear_end() {
  end_ = 0;
}
inline ::google::protobuf::int32 RankReq::end() const {
  // @@protoc_insertion_point(field_get:GameSpec.RankReq.end)
  return end_;
}
inline void RankReq::set_end(::google::protobuf::int32 value) {
  
  end_ = value;
  // @@protoc_insertion_point(field_set:GameSpec.RankReq.end)
}

// -------------------------------------------------------------------

// RankRsp

// .GameSpec.ErrorCode errCode = 1;
inline void RankRsp::clear_errcode() {
  errcode_ = 0;
}
inline ::GameSpec::ErrorCode RankRsp::errcode() const {
  // @@protoc_insertion_point(field_get:GameSpec.RankRsp.errCode)
  return static_cast< ::GameSpec::ErrorCode >(errcode_);
}
inline void RankRsp::set_errcode(::GameSpec::ErrorCode value) {
  
  errcode_ = value;
  // @@protoc_insertion_point(field_set:GameSpec.RankRsp.errCode)
}

// repeated string name = 2;
inline int RankRsp::name_size() const {
  return name_.size();
}
inline void RankRsp::clear_name() {
  name_.Clear();
}
inline const ::std::string& RankRsp::name(int index) const {
  // @@protoc_insertion_point(field_get:GameSpec.RankRsp.name)
  return name_.Get(index);
}
inline ::std::string* RankRsp::mutable_name(int index) {
  // @@protoc_insertion_point(field_mutable:GameSpec.RankRsp.name)
  return name_.Mutable(index);
}
inline void RankRsp::set_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:GameSpec.RankRsp.name)
  name_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void RankRsp::set_name(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:GameSpec.RankRsp.name)
  name_.Mutable(index)->assign(std::move(value));
}
#endif
inline void RankRsp::set_name(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:GameSpec.RankRsp.name)
}
inline void RankRsp::set_name(int index, const char* value, size_t size) {
  name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GameSpec.RankRsp.name)
}
inline ::std::string* RankRsp::add_name() {
  // @@protoc_insertion_point(field_add_mutable:GameSpec.RankRsp.name)
  return name_.Add();
}
inline void RankRsp::add_name(const ::std::string& value) {
  name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:GameSpec.RankRsp.name)
}
#if LANG_CXX11
inline void RankRsp::add_name(::std::string&& value) {
  name_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:GameSpec.RankRsp.name)
}
#endif
inline void RankRsp::add_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:GameSpec.RankRsp.name)
}
inline void RankRsp::add_name(const char* value, size_t size) {
  name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:GameSpec.RankRsp.name)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
RankRsp::name() const {
  // @@protoc_insertion_point(field_list:GameSpec.RankRsp.name)
  return name_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
RankRsp::mutable_name() {
  // @@protoc_insertion_point(field_mutable_list:GameSpec.RankRsp.name)
  return &name_;
}

// repeated int32 exp = 3;
inline int RankRsp::exp_size() const {
  return exp_.size();
}
inline void RankRsp::clear_exp() {
  exp_.Clear();
}
inline ::google::protobuf::int32 RankRsp::exp(int index) const {
  // @@protoc_insertion_point(field_get:GameSpec.RankRsp.exp)
  return exp_.Get(index);
}
inline void RankRsp::set_exp(int index, ::google::protobuf::int32 value) {
  exp_.Set(index, value);
  // @@protoc_insertion_point(field_set:GameSpec.RankRsp.exp)
}
inline void RankRsp::add_exp(::google::protobuf::int32 value) {
  exp_.Add(value);
  // @@protoc_insertion_point(field_add:GameSpec.RankRsp.exp)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
RankRsp::exp() const {
  // @@protoc_insertion_point(field_list:GameSpec.RankRsp.exp)
  return exp_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
RankRsp::mutable_exp() {
  // @@protoc_insertion_point(field_mutable_list:GameSpec.RankRsp.exp)
  return &exp_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace GameSpec

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::GameSpec::ErrorCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GameSpec::ErrorCode>() {
  return ::GameSpec::ErrorCode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_GameSpec_2eproto
